\section{Implémentation}

\begin{figure}[ht]
  \centering
  \input{graphTikZ/reseauAleatoire.tex}
  \caption{Réseau de neurone à deux neurones}
  \label{graphInit}
\end{figure}

\paragraph{}
Nous pouvons voir sur le schéma \ref{graphInit} que trois types d'objets sont
présents dans notre conception d'un réseau de neurones:\\
\begin{description}
  \item[Les stimuli] Réalisés en rouge sur le schéma, ils génèrent les signaux
    qui activent les premiers neurones et ainsi active le réseau.
  \item[Les actions] Affichés en bleu sur le schéma, elles sont les sorties de
    notre système, elles correspondent à la décision effectué par notre réseau.
  \item[Les neurones] Cœur même du réseau, ils sont là pour effectuer la prise
    de décision en fonction des entrées qu'ils possèdent.
\end{description}

\paragraph{}
Ces trois éléments sont donc la base de notre réseau. Ainsi notre classe correspondant
à un réseau de neurones stocke une liste de stimuli, une liste de réactions et une
liste des neurones constituant le réseau.

\paragraph{}
Il a ensuite fallu déterminer la façon de parcourir tous les neurones pour les
mettre à jour. Cette réflexion a fait émerger deux méthodes. Ces méthodes
avaient un impacte sur l'implémentation de la classe neurone. \\

\begin{enumerate}
  \item La première consistait, en partant des réactions, à remonter de façon
    récursive le réseau de neurones afin de récupérer les informations pour
    calculer si oui ou non les réactions ont été activées. Cette méthode implique
    que chaque neurone ait accès à l'ensemble de ses entrées afin de les
    interroger et déterminer lesquelles ont été activées.
  \item La seconde consistait, en partant des stimuli, à propager les informations
    d'activation jusqu'aux réactions. Dans cette méthode quand un neurone a calculé
    si oui ou non il a été activé, il prévient alors l'ensemble de ces sorties de
    son statut. Un neurone recevant une information d'une de ces entrées la
    sauvegarde et si il a reçu l'ensemble des états de ces entrées alors il calcul
    son propre état et le propage de la même manière.
\end{enumerate}

La seconde solution a été choisi car elle semblait plus intuitive dans la
manière de parcourir le réseau (des stimuli vers les réactions). Avec
l'implémentation choisie, on remarque que la validité du réseau est
conditionnée par l'absence des cycles. En effet, s'il existe un cycle il
devient alors impossible de calculer les états des neurones appartenant au
cycle car chaque neurone a besoin des états des autres neurones du cycle.

\paragraph{}
Ne souhaitant pas attribuer aux neurones des caractéristiques qui ne leur étaient
pas nécessaires, nous nous sommes demandé ce qui était intrinsèque au
fonctionnement de l'entité et ce qui relevait de la particularité de notre
réseau. Après réflexion nous sommes arrivé à déterminer comme cœur du neurone, les
parties suivantes:\\

\begin{description}
  \item[Nom]: chaque neurone est doté d'un nom qui permet de le distinguer
    lors de l'envoi de chaque valeur vers les neurones concernés
  \item[Poids]: chaque neurone va pondérer chacune de ses entrées. Ces poids
    sont stockés dans un dictionnaire avec comme clé le nom du neurone et
    comme valeur le poids qui lui est associé.
  \item[Sorties]: la liste des neurones et des réactions connectées à la
    sortie du neurone.
  \item[Inhibiteur]: permet de savoir si le neurone est un inhibiteur ou non.
  \item[Taux d'apprentissage]: le taux de variation des poids du neurone.
\end{description}

\paragraph{}
%TODO Apprentissage


