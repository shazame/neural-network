\section{Implémentation}

\begin{figure}[ht]
  \centering
  \input{graphTikZ/reseauAleatoire.tex}
  \caption{Réseau de neurone à deux neurones}
  \label{graphInit}
\end{figure}

\paragraph{}
Nous pouvons voir sur le schéma \ref{graphInit} que trois types d'objets sont
présents dans notre conception d'un réseau de neurones:\\
\begin{description}
  \item[Les stimuli] Réalisés en rouge sur le schéma, ils génèrent les signaux
    qui activent les premiers neurones et ainsi active le réseau.
  \item[Les actions] Affichés en bleu sur le schéma, elles sont les sorties de
    notre système, elles correspondent à la décision effectué par notre réseau.
  \item[Les neurones] Cœur même du réseau, ils sont là pour effectuer la prise
    de décision en fonction des entrées qu'ils possèdent.
\end{description}

\paragraph{}
Ces trois éléments sont donc la base de notre réseau. Ainsi notre classe correspondant
à un réseau de neurones stockera une liste de stimuli, une liste de réactions et une
liste des neurones constituant le réseau.

\paragraph{}
Il a ensuite fallu déterminer la façon de parcourir tous les neurones pour les
mettre à jour. Cette réflexion a fait émerger deux méthodes. Ces methodes
avaient un impacte sur l'implementation de la classe neurone. \\

\begin{enumerate}
  \item La première consistait en partant des réactions à remonter de façon 
    récursive le réseau de neurones afin de récupérer les informations pour 
    calculer si oui ou non les réactions ont été activitées. Ces méthodes impliquées 
    que chaque neurone est accés à l'ensemble de ces entrées afin de les 
    interroger pour savoir si ils ont été activés.
  \item La seconde consistait en partant des stimuli à propager les informations
    d'activation jusqu'aux réactions. Dans cette méthode quand un neurone a calculé
    si oui ou non il a été activé, il prévient alors l'ensemble de ces sorties de
    son status. Un neurone recevant une information d'une de ces entrées la
    sauvegarde et si il a reçu l'ensemble des états de ces entrées alors il calcul
    son propre état et le progage de la même maniére.
\end{enumerate}

La seconde solution a été choisi car elle semblait plus intuitif sur le 
façon dont le réseau est parcouru (des stimuli vers les réactions). Avec
l'implémentation choisi, on remarque pour que le réseau soit bien valide,
il ne doit pas avoir des cycles dans le réseau. En effet, si il existe un
cycle il devient alors impossible de calculer les états des neurones 
appartenant au cycle car chaque neurone a besoin des états des autres neurones du
cycle.

\paragraph{}
Ne souhaitant pas attribuer aux neurones des caractéristiques qui ne leur étaient
pas nécessaires, nous nous sommes demandé ce qui était intrinsèque au
fonctionnement de l'entité et ce qui relevait de la particularité de notre
réseau. Après réflexion nous sommes arrivé à déterminer comme cœur du neurone, les
parties suivantes:\\

\begin{description}
  \item[Nom] Nous avons décidé d'attribuer à chaque neurone un nom. Ce dernier
    permet de le différencier.
  \item[Poids] Un dictionnaire avec comme clé le nom du neurone et comme valeur
    le poids qui lui est associé.
  \item[Sorties] La liste des neurones et des reactions connecté à la sortie
    du neurone.
  \item[Inhibiteur] Permet de savoir si le neurone est un inhibiteur où non.
  \item[Taux d'apprentissage] Le taux de variation des poids du neurone.
\end{description}

\paragraph{}
%TODO Apprentissage
